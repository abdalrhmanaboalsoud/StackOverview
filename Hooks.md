| Hook                | Parameters                   | Returns                       | Description                                                                                                     | Examples                                                                                             |
|---------------------|------------------------------|-------------------------------|-----------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| **`useState`**      | `initialState`               | `[state, setState]`           | Initializes a piece of state in a functional component. The `state` holds the current value, while `setState` is a function used to update that value. Each call to `setState` triggers a re-render of the component with the new state. This hook is essential for handling local component state. | `const [count, setCount] = useState(0);` <br> `setCount(count + 1);` |
| **`useEffect`**     | `callback, [dependencies]`   | `void`                        | Runs side-effects after every render or when specified dependencies change. The `callback` is executed after the component is rendered and optionally re-runs when dependencies change. This hook is used for operations like data fetching, subscriptions, or manually changing the DOM. If no dependencies are provided, the effect runs on every render. | `useEffect(() => { document.title = \`Count: ${count}\`; }, [count]);` |
| **`useContext`**    | `Context`                    | `value`                       | Allows a component to consume the value from a React Context. By using this hook, you can avoid passing props deeply through the component tree and directly access context values. This is useful for managing global data such as user authentication status or theme settings. | `const user = useContext(UserContext);` |
| **`useReducer`**    | `reducer, initialState, init?` | `[state, dispatch]`         | Manages more complex state logic in a functional component. `reducer` is a function that receives the current state and an action, then returns a new state. `dispatch` is used to send actions to the reducer to update the state. This hook is ideal for handling state with complex logic or multiple state values. | `const [state, dispatch] = useReducer(reducer, initialState);` <br> `dispatch({ type: 'INCREMENT' });` |
| **`useCallback`**   | `callback, [dependencies]`   | `memoizedCallback`            | Returns a memoized version of the `callback` function that only changes if one of the `dependencies` has changed. This hook helps to avoid recreating functions on every render, which can improve performance, especially when passing callbacks to optimized child components. | `const handleClick = useCallback(() => { /* do something */ }, [dependency]);` |
| **`useMemo`**       | `factory, [dependencies]`    | `memoizedValue`               | Returns a memoized value computed from the `factory` function. The value is recomputed only when the `dependencies` change. This hook is useful for optimizing performance by avoiding expensive recalculations of values that do not change often. | `const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);` |
| **`useRef`**        | `initialValue`               | `refObject`                   | Returns a mutable `ref` object whose `.current` property persists across renders. This hook is commonly used to reference DOM elements directly or store mutable values that do not cause re-renders when changed. | `const inputRef = useRef(null);` <br> `inputRef.current.focus();` |
| **`useImperativeHandle`** | `ref, createHandle, [dependencies]` | `void` | Customizes the instance value exposed to parent components when using `ref`. This hook is used with `forwardRef` to expose specific methods or properties to parent components, giving more control over what is exposed. | `useImperativeHandle(ref, () => ({ focus: () => inputRef.current.focus() }), []);` |
| **`useLayoutEffect`** | `callback, [dependencies]` | `void`                        | Similar to `useEffect`, but runs synchronously after all DOM mutations. This hook is used for reading layout properties and synchronously re-rendering before the browser paints. It is ideal for operations that need to be done immediately after DOM updates. | `useLayoutEffect(() => { /* read layout and set state */ }, [dependency]);` |
| **`useDebugValue`** | `value`                      | `void`                        | Adds a label to React DevTools for custom hooks. This hook helps with debugging by providing a human-readable label in DevTools to understand the current state of custom hooks. | `useDebugValue(isOnline ? 'Online' : 'Offline');` |
| **`useTransition`** | `void`                       | `[isPending, startTransition]` | Allows you to mark updates as transitions to manage rendering priority. `isPending` indicates if a transition is ongoing, and `startTransition` is a function used to start a transition. This hook is useful for optimizing UI updates by deferring non-urgent state changes. | `startTransition(() => { setState(newValue); });` |
| **`useDeferredValue`** | `value`                   | `deferredValue`               | Defers updating a value, allowing React to keep the UI responsive by rendering lower-priority updates in the background. Ideal for large or complex updates that do not need to be reflected immediately. | `const deferredValue = useDeferredValue(inputValue);` |
| **`useId`**         | `void`                       | `uniqueId`                    | Generates a unique ID that is consistent across server and client renders. This hook is useful for ensuring that IDs are unique and consistent, which is important for accessibility and form labeling. | `const id = useId();` <br> `<label htmlFor={id}>Name</label> <input id={id} />` |
| **`useSyncExternalStore`** | `subscribe, getSnapshot, getServerSnapshot` | `state` | Allows components to subscribe to external stores, ensuring that they stay synchronized with the store’s state. This hook is crucial for integrating with external state management systems and ensures that the component renders consistently on both the server and client. | `const state = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);` |
| **`useInsertionEffect`** | `callback, [dependencies]` | `void`                     | Runs a synchronous effect before DOM mutations. This hook is ideal for injecting critical styles or making adjustments that must be applied immediately before the DOM updates. | `useInsertionEffect(() => { /* inject style */ }, [dependency]);` |
| **`useErrorBoundary`** | `void`                    | `[ErrorBoundary, resetErrorBoundary]` | Provides error handling capabilities to catch and manage errors in the component tree. `resetErrorBoundary` is a function that allows resetting the error state, enabling recovery from errors. | `<ErrorBoundary fallback={<FallbackComponent />}> <MyComponent /> </ErrorBoundary>` |
| **`useRouter` (Next.js)** | `void`                 | `router`                      | Provides access to Next.js' router object for programmatic navigation and route handling. This hook allows you to perform actions like navigation, route querying, and handling dynamic routes. | `const router = useRouter();` <br> `router.push('/about');` |
| **`useQuery` (Next.js)**  | `queryKey, queryFn, options` | `data, isLoading, error`  | Manages data fetching and caching using React Query. `queryKey` is a unique identifier for the query, `queryFn` is the function that fetches data, and `options` can configure caching, retries, and other behaviors. This hook simplifies the management of server-state. | `const { data, isLoading, error } = useQuery('todos', fetchTodos);` |
| **`useMutation` (Next.js)** | `mutationFn, options` | `mutate, isLoading, error` | Handles data mutations (e.g., POST, PUT requests) using React Query. `mutationFn` is the function that performs the mutation, and `options` configure aspects like retries and cache invalidation. This hook is used for submitting data to the server. | `const { mutate } = useMutation(addTodo);` <br> `mutate(newTodo);` |
| **`useForm` (Next.js)**    | `options`               | `methods`                     | Manages form state and validation with minimal boilerplate. This hook provides utilities for handling form submissions, validations, and state management. It helps streamline form handling in Next.js applications. | `const { register, handleSubmit } = useForm();` <br> `<input {...register('name')} />` |
| **`useTheme` (Next.js)**   | `void`                 | `theme`                       | Provides access to the current theme settings, allowing components to adapt their appearance based on the theme (e.g., light or dark mode). This hook is useful for implementing theme-based UI adjustments. | `const theme = useTheme();` <br> `theme.setTheme('dark');` |
| **`useMediaQuery`** | `query`                      | `matches`                     | Monitors a CSS media query and returns a boolean indicating whether it matches the current viewport. Useful for implementing responsive designs and conditional rendering based on screen size. | `const isLargeScreen = useMediaQuery('(min-width: 1024px)');` |
| **`usePrevious`**   | `value`                      | `previousValue`               | Stores and returns the previous value of a state or prop. This hook is helpful for comparing past and current values, making it easier to implement logic based on changes over time. | `const prevCount = usePrevious(count);` |
| **`useLocalStorage`** | `key, initialValue`        | `[storedValue, setValue]`     | Manages a stateful value that is synchronized with `localStorage`. The state persists across sessions and page reloads. This hook is useful for storing user preferences or other persistent data. | `const [name, setName] = useLocalStorage('name', 'John');` |
| **`useSessionStorage`** | `key, initialValue`     | `[storedValue, setValue]`     | Manages a stateful value that is synchronized with `sessionStorage`. The state persists only for the duration of the page session. This hook is useful for temporary data that should not persist across sessions. | `const [sessionData, setSessionData] = useSessionStorage('sessionKey', 'defaultValue');` |
| **`useToggle`**     | `initialValue`               | `[state, toggle]`             | Provides a boolean state with an accompanying `toggle` function to switch between true and false values. Useful for handling UI elements that need to switch between two states, such as modals or toggles. | `const [isOn, toggleIsOn] = useToggle(false);` |
| **`useHover`**      | `ref`                        | `[isHovered, bind]`           | Tracks the hover state of an element referenced by `ref`. The `isHovered` boolean indicates if the element is currently being hovered, and `bind` should be spread onto the element’s props. Useful for implementing hover-based styles or behaviors. | `const [isHovered, bind] = useHover();` <br> `<div {...bind}>Hover me!</div>` |
| **`useFocus`**      | `ref`                        | `[isFocused, bind]`           | Tracks the focus state of an element referenced by `ref`. The `isFocused` boolean indicates if the element is currently focused, and `bind` should be spread onto the element’s props. Useful for managing focus-based styles or behaviors. | `const [isFocused, bind] = useFocus();` <br> `<input {...bind} />` |
| **`useClickOutside`** | `ref, handler`            | `void`                        | Detects clicks outside of a specified element and triggers the provided `handler` function. Useful for closing dropdowns, modals, or other components when clicking outside their bounds. | `useClickOutside(ref, () => setIsOpen(false));` |
| **`useFetch`**      | `url, options`               | `[data, loading, error]`      | Simplifies data fetching with the Fetch API, returning the data, loading status, and any error encountered. This hook manages the state of the request, making it easier to handle loading states and errors. | `const [data, loading, error] = useFetch('/api/data');` |
| **`useIntersectionObserver`** | `ref, options`     | `[entry, observer]`           | Monitors the visibility of an element within the viewport using the Intersection Observer API. The `entry` object contains information about the intersection, and `observer` is the Intersection Observer instance. Useful for implementing lazy loading or triggering animations based on visibility. | `const [entry] = useIntersectionObserver(ref, { threshold: 0.1 });` |
| **`useTimeout`**    | `callback, delay`            | `void`                        | Executes a `callback` function after a specified `delay` using `setTimeout`. The timeout is automatically cleared when the component unmounts, preventing memory leaks. Useful for delaying operations or triggering actions after a period. | `useTimeout(() => { setReady(true); }, 1000);` |
| **`useInterval`**   | `callback, interval`         | `void`                        | Executes a `callback` function repeatedly at a specified `interval` using `setInterval`. The interval is automatically cleared when the component unmounts. Useful for recurring tasks like updating a clock or polling for data. | `useInterval(() => { setTime(new Date()); }, 1000);` |
| **`useDebounce`**   | `value, delay`               | `debouncedValue`              | Delays updating the `value` until after a specified `delay` has passed without further changes. This hook prevents excessive updates and improves performance for scenarios like live search or input throttling. | `const debouncedSearchTerm = useDebounce(searchTerm, 500);` |
| **`useThrottle`**   | `value, limit`               | `throttledValue`              | Limits updates to the `value` to once every specified `limit` time interval. This hook helps to manage high-frequency events like scrolling or resizing, ensuring that operations are performed at controlled intervals. | `const throttledValue = useThrottle(inputValue, 1000);` |
| **`useCopyToClipboard`** | `text`                 | `[copied, copy]`              | Provides functionality to copy `text` to the clipboard and indicates whether the copy operation was successful. The `copy` function is used to perform the copy action, and `copied` is a boolean indicating the success of the operation. | `const [copied, copy] = useCopyToClipboard();` <br> `copy('Hello, World!');` |
| **`useTitle`**      | `title`                      | `void`                        | Updates the document title dynamically based on the `title` parameter. This hook is useful for changing the page title in response to application state changes, enhancing user experience and SEO. | `useTitle('My App - Home');` |
| **`useOnlineStatus`** | `void`                    | `isOnline`                    | Monitors and returns the network connectivity status of the user. `isOnline` is a boolean indicating whether the user is online or offline. This hook can be used to adjust the app behavior based on network status. | `const isOnline = useOnlineStatus();` |
| **`useGeolocation`** | `options`                  | `[position, error]`           | Retrieves the user's geographic location with `latitude` and `longitude` using the Geolocation API. Returns `position` with coordinates or `error` if geolocation is unavailable or permission is denied. Useful for location-based features. | `const [position, error] = useGeolocation();` |
| **`useWindowSize`** | `void`                       | `[width, height]`             | Tracks the current dimensions (width and height) of the browser window, updating automatically when the window is resized. Useful for responsive design and adjusting layout based on screen size. | `const [width, height] = useWindowSize();` |
| **`useScrollPosition`** | `void`                  | `[x, y]`                      | Monitors the current scroll position of the window on both X and Y axes. Returns `[x, y]` coordinates indicating the scroll position, useful for implementing features like sticky headers or infinite scrolling. | `const [scrollX, scrollY] = useScrollPosition();` |
| **`useIsomorphicLayoutEffect`** | `callback, [dependencies]` | `void`  | Runs a layout effect that is consistent between server-side rendering (SSR) and client-side rendering (CSR). The effect runs once during hydration, ensuring that it behaves similarly in both environments. Ideal for use in Next.js applications. | `useIsomorphicLayoutEffect(() => { /* perform layout adjustments */ }, [dependency]);` |
